"""Repo builder -- assembles poisoned test repositories."""

from __future__ import annotations

from importlib.resources import files as resource_files
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from importlib.abc import Traversable

import jinja2

from countersignal.cxp.models import Technique
from countersignal.cxp.techniques import list_techniques


def _copy_tree(source: Traversable, dest: Path) -> None:
    """Recursively copy a Traversable directory tree to a filesystem path.

    Args:
        source: Source directory (importlib.resources Traversable).
        dest: Destination filesystem path.
    """
    for item in source.iterdir():
        if item.is_file():
            target = dest / item.name
            target.write_text(item.read_text(encoding="utf-8"), encoding="utf-8")
        elif item.is_dir():
            subdir = dest / item.name
            subdir.mkdir(parents=True, exist_ok=True)
            _copy_tree(item, subdir)


def _render_template(technique: Technique) -> str:
    """Render a technique's Jinja2 template with technique metadata.

    Args:
        technique: The technique whose template to render.

    Returns:
        Rendered template content.
    """
    env = jinja2.Environment(
        autoescape=True,
        undefined=jinja2.StrictUndefined,
        keep_trailing_newline=True,
    )
    template = env.from_string(technique.template)
    result: str = template.render(
        objective_id=technique.objective.id,
        format_id=technique.format.id,
        technique_id=technique.id,
    )
    return result


def _generate_trigger_md(technique: Technique) -> str:
    """Generate TRIGGER.md content for a technique.

    Args:
        technique: The technique to document.

    Returns:
        TRIGGER.md content string.
    """
    return f"""# Testing Instructions

## Technique: {technique.id}
## Objective: {technique.objective.name}
## Target Assistant: {technique.format.assistant}

## Setup
1. Open this directory in {technique.format.assistant}
2. Ensure the assistant reads `{technique.format.filename}`

## Trigger Prompt
Copy and paste this prompt into the assistant:

> {technique.trigger_prompt}

## What to Look For
{technique.objective.description}

## Recording Results
```
countersignal cxp record --technique {technique.id} --assistant "{technique.format.assistant}" \\
    --trigger-prompt "{technique.trigger_prompt}" --file <path-to-generated-code>
```
"""


def _generate_readme(technique: Technique) -> str:
    """Generate README.md with security warnings.

    Args:
        technique: The technique this repo tests.

    Returns:
        README.md content string.
    """
    return f"""# CounterSignal CXP Test Repository

## WARNING -- SECURITY RESEARCH MATERIAL

**This repository contains intentionally malicious instruction files.**

It was generated by CounterSignal CXP, a context poisoning tester for AI coding assistants.
The instruction files in this repo are designed to manipulate coding assistants into
generating insecure or malicious code.

**Do not use this repository for any purpose other than authorized security testing.**

## Details

- **Technique:** {technique.id}
- **Objective:** {technique.objective.name}
- **Target Assistant:** {technique.format.assistant}
- **Poisoned File:** `{technique.format.filename}`

## How to Use

See `TRIGGER.md` for testing instructions.

## Disclaimer

This material is provided for authorized security research and red-team testing only.
The authors are not responsible for misuse. Always obtain proper authorization before
testing against systems you do not own.
"""


def build_repo(technique: Technique, output_dir: Path) -> Path:
    """Build a test repo for the given technique.

    Creates a directory with the poisoned instruction file, trigger document,
    project skeleton, and security-warning README.

    Args:
        technique: The technique to build a repo for.
        output_dir: Parent directory for the generated repo.

    Returns:
        Path to the created repo directory.
    """
    repo_dir = output_dir / technique.id
    repo_dir.mkdir(parents=True, exist_ok=True)

    # Copy project skeleton
    skeleton = resource_files("countersignal.cxp.techniques") / "skeleton"
    _copy_tree(skeleton, repo_dir)

    # Render and write poisoned instruction file
    rendered = _render_template(technique)
    poisoned_path = repo_dir / technique.format.filename
    poisoned_path.parent.mkdir(parents=True, exist_ok=True)
    poisoned_path.write_text(rendered, encoding="utf-8")

    # Write TRIGGER.md
    (repo_dir / "TRIGGER.md").write_text(_generate_trigger_md(technique), encoding="utf-8")

    # Write README.md (overwrites skeleton README)
    (repo_dir / "README.md").write_text(_generate_readme(technique), encoding="utf-8")

    return repo_dir


def build_all(
    output_dir: Path,
    objective: str | None = None,
    format_id: str | None = None,
) -> list[Path]:
    """Build repos for all techniques, optionally filtered.

    Args:
        output_dir: Parent directory for generated repos.
        objective: Filter to this objective ID only.
        format_id: Filter to this format ID only.

    Returns:
        List of paths to created repo directories.
    """
    techniques = list_techniques()
    if objective:
        techniques = [t for t in techniques if t.objective.id == objective]
    if format_id:
        techniques = [t for t in techniques if t.format.id == format_id]
    return [build_repo(t, output_dir) for t in techniques]
